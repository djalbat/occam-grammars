"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var bnf = "document                             ::=   ( rule | axiom | lemma | theorem | conjecture | metalemma | metatheorem | metaconjecture | declaration | verticalSpace | error )+ ;\n\n\n\nrule                                 ::=   \"Rule\" \"(\" labels \")\" <END_OF_LINE> ( premise | premises )? conclusion metaproof? ;\n\naxiom                                ::=   \"Axiom\" \"(\" labels \")\" <END_OF_LINE> ( indicativeConditional | unqualifiedStatement | unqualifiedNonsense ) ; \n\nlemma                                ::=   \"Lemma\" \"(\" labels \")\"? <END_OF_LINE> ( indicativeConditional | unqualifiedStatement | unqualifiedNonsense ) proof ;\n\ntheorem                              ::=   \"Theorem\" \"(\" labels \")\" <END_OF_LINE> ( indicativeConditional | unqualifiedStatement | unqualifiedNonsense ) proof ;\n\nconjecture                           ::=   \"Conjecture\" \"(\" labels \")\" <END_OF_LINE> ( indicativeConditional | unqualifiedStatement | unqualifiedNonsense ) proof? ;\n\nmetalemma                            ::=   \"Metalemma\" \"(\" labels \")\" <END_OF_LINE> ( metaIndicativeConditional | unqualifiedMetastatement | unqualifiedNonsense ) metaproof ;\n\nmetatheorem                          ::=   \"Metatheorem\" \"(\" labels \")\" <END_OF_LINE> ( metaIndicativeConditional | unqualifiedMetastatement | unqualifiedNonsense ) metaproof ;\n\nmetaconjecture                       ::=   \"Metaconjecture\" \"(\" labels \")\" <END_OF_LINE> ( metaIndicativeConditional | unqualifiedMetastatement | unqualifiedNonsense ) ;\n\n\n\ndeclaration                          ::=   typeDeclaration \n                                           \n                                       |   variableDeclaration \n                                           \n                                       |   operatorDeclaration \n                                           \n                                       |   constructorDeclaration \n                                           \n                                       |   disjointTypeDeclaration \n                                           \n                                       |   metavariableDeclaration \n                                           \n                                       |   dependentTypeDeclaration \n                                           \n                                       |   abbreviationDeclaration \n                                           \n                                       |   typesDeclaration \n                                           \n                                       |   variablesDeclaration \n                                           \n                                       |   operatorsDeclaration \n                                           \n                                       |   constructorsDeclaration \n                                           \n                                       |   disjointTypesDeclaration \n                                           \n                                       |   metavariablesDeclaration \n                                           \n                                       |   dependentTypesDeclaration \n                                           \n                                       |   abbreviationsDeclaration\n                                       \n                                       ;\n\n\n\ntypeDeclaration                      ::=   \"Type\" typeName ( \":\" typeName )? <END_OF_LINE> ;\n \nvariableDeclaration                  ::=   \"Variable\" variableName \":\" typeName <END_OF_LINE> ;\n \noperatorDeclaration                  ::=   \"Operator\" expression ( \":\" typeName )? <END_OF_LINE> ;\n \nconstructorDeclaration               ::=   \"Constructor\" term ( \":\" typeName )? <END_OF_LINE> ;\n \ndisjointTypeDeclaration              ::=   \"DisjointType\" typeName \":\" typeNames <END_OF_LINE> ;\n                                       \nmetavariableDeclaration              ::=   \"Metavariable\" metavariableName typeParameter? \":\" ( \"Statement\" | \"Context\" ) <END_OF_LINE> ;\n \ndependentTypeDeclaration             ::=   \"DependentType\" typeName typeParameter \":\" typeName <END_OF_LINE> ;\n                                       \nabbreviationDeclaration              ::=   \"Abbreviation\" abbreviation <END_OF_LINE> ;\n\ntypesDeclaration                     ::=   \"Types\" typeNames ( \":\" typeName )? <END_OF_LINE> ;\n\nvariablesDeclaration                 ::=   \"Variables\" variableName ( \",\" variableName )+ \":\" typeName <END_OF_LINE> ;\n \noperatorsDeclaration                 ::=   \"Operators\" expression ( \",\" expression )+ ( \":\" typeName )? <END_OF_LINE> ;\n \nconstructorsDeclaration              ::=   \"Constructors\" term ( \",\" term )+ ( \":\" typeName )? <END_OF_LINE> ;\n \ndisjointTypesDeclaration             ::=   \"DisjointTypes\" typeNames \":\" typeNames <END_OF_LINE> ;\n \nmetavariablesDeclaration             ::=   \"Metavariables\" metavariableName typeParameter? ( \",\" metavariableName typeParameter? )+ \":\" ( \"Statement\" | \"Context\" ) <END_OF_LINE> ;\n \ndependentTypesDeclaration            ::=   \"DependentTypes\" typeName typeParameter ( \",\" typeName typeParameter )+ \":\" typeName <END_OF_LINE> ;\n \nabbreviationsDeclaration             ::=   \"Abbreviations\" abbreviation ( \",\" abbreviation )+ <END_OF_LINE> ;\n \n\n  \npremise                              ::=   \"Premise\" <END_OF_LINE> ( unqualifiedMetastatement | unqualifiedNonsense ) ;\n\npremises                             ::=   \"Premises\" <END_OF_LINE> ( unqualifiedMetastatement | unqualifiedNonsense ) ( unqualifiedMetastatement | unqualifiedNonsense )+ ;\n\nconclusion                           ::=   \"Conclusion\" <END_OF_LINE> ( qualifiedMetastatement | qualifiedNonsense ) ;\n\n\n\nmetaproof                            ::=   \"Proof\" <END_OF_LINE> \n\n                                           metastatementDefinition*\n\n                                           nonsenseDefinition*\n\n                                           metaProofDerivation? \n                                          \n                                           ( qualifiedMetastatement | qualifiedNonsense ) ;\n                                          \n                                          \n\nmetaProofDerivation                  ::=   ( metaSublemma | qualifiedMetastatement | qualifiedStatement | qualifiedNonsense )+  \n\n                                           \"Therefore\" <END_OF_LINE> ;                                           \n\nmetaIndicativeConditional            ::=   \"Suppose\" <END_OF_LINE> ( unqualifiedMetastatement | unqualifiedNonsense )+ \n\n                                           \"Hence\" <END_OF_LINE> ( qualifiedMetastatement | qualifiedNonsense ) ;\n\nmetaSublemma                         ::=   \"Suppose\" <END_OF_LINE> \n\n                                           ( metaSublemma | qualifiedMetastatement | qualifiedStatement | qualifiedNonsense )+ \n\n                                           ( \n                                          \n                                             \"Then\" <END_OF_LINE> \n                                            \n                                             ( metaSublemma | qualifiedMetastatement | qualifiedStatement | qualifiedNonsense )+ \n                                          \n                                           )? \n                                          \n                                           \"Hence\" <END_OF_LINE> ( qualifiedMetastatement | qualifiedNonsense ) ;\n\n\n\nproof                                ::=   \"Proof\" <END_OF_LINE> \n\n                                           statementDefinition*\n\n                                           nonsenseDefinition*\n\n                                           proofDerivation? \n                                          \n                                           ( qualifiedStatement | qualifiedNonsense ) ;\n                                                                                         \n                                                                                         \n                                                                                         \nproofDerivation                      ::=   ( sublemma | qualifiedStatement | qualifiedNonsense )+ \n\n                                           \"Therefore\" <END_OF_LINE> ;\n\nindicativeConditional                ::=   \"Suppose\" <END_OF_LINE> ( unqualifiedStatement | unqualifiedNonsense )+ \n\n                                           \"Hence\" <END_OF_LINE> ( qualifiedStatement | qualifiedNonsense ) ;\n\nsublemma                             ::=   \"Suppose\" <END_OF_LINE> \n\n                                           ( subLemma | qualifiedStatement | qualifiedNonsense )+ \n\n                                           ( \n                                          \n                                             \"Then\" <END_OF_LINE> \n                                            \n                                             ( subLemma | qualifiedStatement | qualifiedNonsense )+ \n                                          \n                                           )? \n                                          \n                                           \"Hence\" <END_OF_LINE> ( qualifiedStatement | qualifiedNonsense ) ;\n\n\n\nmetastatementDefinition              ::=   \"Let\" unqualifiedMetastatement ;                                           \n                                          \nstatementDefinition                  ::=   \"Let\" unqualifiedStatement ;                                           \n\nnonsenseDefinition                   ::=   \"Let\" unqualifiedNonsense ;                                           \n\n\n\nunqualifiedMetastatement             ::=   metastatement! <END_OF_LINE> ;\n\nunqualifiedStatement                 ::=   statement! <END_OF_LINE> ;\n\nunqualifiedNonsense                  ::=   nonsense! <END_OF_LINE> ;\n\n\n\nqualifiedMetastatement               ::=   metastatement! qualification? <END_OF_LINE> ;\n\nqualifiedStatement                   ::=   statement! qualification? <END_OF_LINE> ;\n\nqualifiedNonsense                    ::=   nonsense! qualification? <END_OF_LINE> ;\n\n\n\nnonsense                             ::=   ( [name] | [custom] | [special] | [reserved] | [unassigned] )+ ;\n\n\n\nqualification                        ::=   ( \"by\" | \"from\" ) reference ;\n\n\n\ntypeParameter                        ::=   ( <NO_WHITESPACE>\"(\" typeName \")\" ) ;\n\n\n\nabbreviation                         ::=   [custom] \"for\" [custom] | name \"for\" name ;\n\n\n\nmetavariable                         ::=   metavariableName ( <NO_WHITESPACE>\"(\" term \")\" )? ;\n\nreference                            ::=   referenceName ( <NO_WHITESPACE>\"(\" term \")\" )? ;\n\ncontext                              ::=   contextName ( <NO_WHITESPACE>\"(\" term \")\" )? ;\n\nlabel                                ::=   labelName ( <NO_WHITESPACE>\"(\" term \")\" )? ;\n\n\n\ntypeNames                            ::=   typeName ( \",\" typeName )* ;\n\nlabels                               ::=   label ( \",\" label )* ;\n\n\n\nmetavariableName                     ::=   [name] ;\n\nreferenceName                        ::=   [name] ;\n\nvariableName                         ::=   [name] ;\n\ncontextName                          ::=   [name] ;\n\nlabelName                            ::=   [name] ;\n\ntypeName                             ::=   [name] ;\n\nname                                 ::=   [name] ;\n\n\n\nverticalSpace                        ::=   <END_OF_LINE>+ ;\n\n\n\nerror                                ::=   . ;";
var _default = bnf;
exports.default = _default;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9mbG9yZW5jZS9ibmYuanMiXSwibmFtZXMiOlsiYm5mIl0sIm1hcHBpbmdzIjoiQ0FBQSxVQUFZOzs7OztBQUVaLEdBQUssQ0FBQyxHQUFHLElBQUksZ2lYQXdQaUM7ZUFFL0IsR0FBRyJ9